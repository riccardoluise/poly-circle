<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cerchi Luminosi e Sonori</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            border: 1px solid #333;
        }
        #startButton {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="myCanvas"></canvas>
    <button id="startButton">Avvia Audio</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = Math.min(canvas.width, canvas.height) * 0.4;
        const numRays = 64;

        class Circle {
            constructor(angle) {
                this.angle = angle;
                this.distance = radius;
                this.speed = Math.random() * 1 + 0.5;
                this.direction = -1;
                this.borderGlow = 0;
            }

            update() {
                this.distance += this.speed * this.direction;
                if (this.distance > radius || this.distance < 0) {
                    this.direction *= -1;
                    if (this.distance > radius) {
                        this.borderGlow = 1;
                        playNote(this.angle / (Math.PI * 2));
                    }
                }
                this.borderGlow *= 0.9;
            }

            draw() {
                const x = centerX + Math.cos(this.angle) * this.distance;
                const y = centerY + Math.sin(this.angle) * this.distance;
                
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
                
                if (this.borderGlow > 0) {
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${this.borderGlow})`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
            }
        }

        const circles = [];
        for (let i = 0; i < numRays; i++) {
            circles.push(new Circle((i / numRays) * Math.PI * 2));
        }

        function drawRays() {
            ctx.beginPath();
            for (let i = 0; i < numRays; i++) {
                const angle = (i / numRays) * Math.PI * 2;
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * radius,
                    centerY + Math.sin(angle) * radius
                );
            }
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.stroke();
        }

        function drawCircumference() {
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.stroke();
        }

        let synth, reverb, compressor;

        function initAudio() {
            Tone.context.updateInterval = 0.1;
            Tone.context.lookAhead = 0.1;

            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: {
                    type: 'sine'
                },
                envelope: {
                    attack: 0.02,
                    decay: 0.1,
                    sustain: 0.2,
                    release: 0.8
                }
            }).toDestination();

            reverb = new Tone.Reverb({
                decay: 2,
                wet: 0.3
            }).toDestination();

            compressor = new Tone.Compressor({
                threshold: -24,
                ratio: 12,
                attack: 0.003,
                release: 0.25
            }).toDestination();

            synth.chain(reverb, compressor);
        }

        const notes = [
            'C2', 'C#2', 'D2', 'D#2', 'E2', 'F2', 'F#2', 'G2', 'G#2', 'A2', 'A#2', 'B2',
            'C3', 'C#3', 'D3', 'D#3', 'E3', 'F3', 'F#3', 'G3', 'G#3', 'A3', 'A#3', 'B3',
            'C4', 'C#4', 'D4', 'D#4', 'E4', 'F4', 'F#4', 'G4', 'G#4', 'A4', 'A#4', 'B4',
            'C5', 'C#5', 'D5', 'D#5', 'E5', 'F5', 'F#5', 'G5', 'G#5', 'A5', 'A#5', 'B5',
            'C6', 'C#6', 'D6', 'D#6', 'E6', 'F6', 'F#6', 'G6', 'G#6', 'A6', 'A#6', 'B6'
        ];

        function playNote(position) {
            if (!synth) return;
            const noteIndex = Math.floor(position * notes.length);
            synth.triggerAttackRelease(notes[noteIndex], '16n', undefined, 0.2);
        }

        let lastFrameTime = 0;
        const targetFPS = 30;
        const frameInterval = 1000 / targetFPS;

        function animate(currentTime) {
            if (currentTime - lastFrameTime < frameInterval) {
                requestAnimationFrame(animate);
                return;
            }

            lastFrameTime = currentTime;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawCircumference();
            drawRays();
            circles.forEach(circle => {
                circle.update();
                circle.draw();
            });

            requestAnimationFrame(animate);
        }

        const startButton = document.getElementById('startButton');
        startButton.addEventListener('click', async () => {
            await Tone.start();
            initAudio();
            startButton.style.display = 'none';
            requestAnimationFrame(animate);
        });
    </script>
</body>
</html>
